---
description:
globs:
alwaysApply: true
---
# Next.js 14 + Prisma + Clerk + TypeScript Best Practices

## ðŸš€ Core Principles

### 1. Type Generation is Non-Negotiable

```bash
# After ANY schema change:
cd packages/db && bun db:push

# Types are auto-generated by Prisma:
# - packages/db/prisma/types.ts (Kysely types)
# - packages/db/prisma/enums.ts (TypeScript enums)

# Automate with git hooks:
# .husky/pre-commit
if git diff --cached --name-only | grep -q "schema.prisma"; then
  bun db:push
  git add packages/db/prisma/types.ts packages/db/prisma/enums.ts
fi
```

Supabase is only used for file storage. The project uses:
Clerk for auth
Prisma + PostgreSQL for database
Supabase Storage for file uploads

### 2. Server-First Architecture (Next.js 15.3)

```typescript
// âœ… Server Components by default
export default async function Page() {
  const data = await getServerData() // Direct DB calls
  return <ClientComponent initialData={data} />
}

// âœ… Use after() for non-blocking operations
import { after } from 'next/server'

export async function createPost(data: PostInput) {
  const post = await db.posts.create(data)
  
  after(async () => {
    // Non-blocking: analytics, cache warming, webhooks
    await trackEvent('post_created', { postId: post.id })
    await sendNotification(post.authorId)
  })
  
  return post
}
```

### 3. Database Access with Kysely

```typescript
// lib/db.ts - Type-safe database queries
import { Kysely, PostgresDialect } from 'kysely'
import { Pool } from 'pg'
import type { Database } from '@saasfly/db/prisma/types'

// Create a singleton database instance
const dialect = new PostgresDialect({
  pool: new Pool({
    connectionString: process.env.POSTGRES_URL,
  }),
})

export const db = new Kysely<Database>({ dialect })

// Example query (fully type-safe):
const projects = await db
  .selectFrom('Project')
  .where('userId', '=', userId)
  .selectAll()
  .execute()
```
### Prisma Migration-First Development

When working with the database, **ALWAYS** use Prisma for schema changes:

### Core Rules

1. **NEVER modify the database directly** - No manual SQL commands
    
2. **ALWAYS update the Prisma schema** for any changes:
    
    ```bash
    # Edit packages/db/prisma/schema.prisma
    # Then apply changes:
    cd packages/db && bun db:push
    ```
    
3. **Schema editing best practices**:
    
    - Add models in `schema.prisma`
    - Use descriptive enum names
    - Add indexes with `@@index([field])`
    - Use `@updatedAt` for auto-updating timestamps
    - Set proper relations with `onDelete: Cascade`
    
4. **After EVERY schema change**:
    ```bash
    cd packages/db && bun db:push
    # Kysely types auto-generated in packages/db/prisma/types.ts
    ```
    
5. **Example workflow for adding a field**:
    ```prisma
    # Edit packages/db/prisma/schema.prisma
    model Project {
      id        String   @id @default(dbgenerated("gen_random_uuid()"))
      title     String
      viewCount Int      @default(0) // âœ… Add new field
      createdAt DateTime @default(now())
      updatedAt DateTime @updatedAt
    }
    ```
    
    ```bash
    # Apply changes:
    cd packages/db && bun db:push
    ```
    
6. **Include in schema design**:
    
    - Proper indexes for query performance
    - `@updatedAt` for tracking changes
    - Cascade deletes for related data
    - Enums for fixed value sets
    
7. **Commit workflow**:
    
    - Commit `schema.prisma` changes
    - Generated types auto-update on team members' `bun install`

This ensures type-safe queries and reproducible schema across all environments.

## ðŸ“ Project Structure (Next.js 15.3 + Supabase)

```
â”œâ”€â”€ app/                      # App Router
â”‚   â”œâ”€â”€ [lang]/
â”‚   â”‚   â”œâ”€â”€ (auth)/          # Auth group routes
â”‚   â”‚   â”œâ”€â”€ (dashboard)/     # Protected routes
â”‚   â”‚   â””â”€â”€ (marketing)/     # Landing, pricing
â”‚   â””â”€â”€ api/                 # API routes
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ui/                  # shadcn/ui components
â”‚   â””â”€â”€ features/            # Feature components
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ db.ts               # Kysely database client
â”‚   â””â”€â”€ utils.ts            # cn() + helpers
â”œâ”€â”€ server/                  # Server-only code (optional)
â”‚   â”œâ”€â”€ queries/            # DB queries
â”‚   â””â”€â”€ actions/            # Server Actions
â”œâ”€â”€ hooks/                   # Client hooks
â”œâ”€â”€ test/                    # Test utilities
â”‚   â””â”€â”€ setup.ts            # Vitest setup
â””â”€â”€ packages/
    â””â”€â”€ db/
        â””â”€â”€ prisma/
            â”œâ”€â”€ schema.prisma  # Database schema
            â”œâ”€â”€ types.ts       # Generated Kysely types
            â””â”€â”€ enums.ts       # Generated enums
```

## ðŸŽ¯ Next.js 15.3 Patterns

### Server Actions with Revalidation

```typescript
// server/actions/posts.ts
'use server'

import { revalidateTag, revalidatePath } from 'next/cache'
import { after } from 'next/server'

export async function createPost(formData: PostInput) {
  const { userId } = await auth() // Clerk auth
  if (!userId) throw new Error('Unauthorized')
  
  // Type-safe Kysely query
  const post = await db
    .insertInto('Post')
    .values({
      ...formData,
      userId,
      createdAt: new Date(),
    })
    .returningAll()
    .executeTakeFirstOrThrow()

  // Immediate revalidation
  revalidateTag('posts')
  revalidatePath('/dashboard')
  
  // Deferred operations
  after(async () => {
    await notifySubscribers(post.id)
  })

  return post
}
```

### Form Component with Prefetching

```typescript
// Using Next.js 15.3 stable Form component
import Form from 'next/form'

export function SearchForm() {
  return (
    <Form action="/search" prefetch={true}>
      <input name="q" placeholder="Search..." />
      <button type="submit">Search</button>
    </Form>
  )
}
```

### Connection API for Performance

```typescript
// Warm connections early for better performance
import { connection } from 'next/server'

export default async function Layout({ children }) {
  // Pre-warm database connection
  await connection()
  
  // Pre-connect to external services
  await fetch('https://api.service.com/warmup', { 
    method: 'HEAD' 
  })
  
  return <>{children}</>
}
```

## ðŸ” Authentication Pattern (Clerk)

The starter uses Clerk for authentication:
- Sign up/Sign in pages at `/en/register` and `/en/login-clerk`
- Protected dashboard routes under `app/[lang]/(dashboard)/`
- Clerk middleware handles session management
- User sync via Clerk webhooks

```typescript
// middleware.ts
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

const isProtectedRoute = createRouteMatcher([
  '/dashboard(.*)',
  '/settings(.*)',
])

export default clerkMiddleware((auth, req) => {
  if (isProtectedRoute(req)) auth().protect()
})

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
}

// app/[lang]/(dashboard)/layout.tsx
import { auth } from '@clerk/nextjs/server'
import { redirect } from 'next/navigation'

export default async function DashboardLayout({ children }) {
  const { userId } = await auth()
  
  if (!userId) redirect('/en/login-clerk')
  
  return <>{children}</>
}

// Using Clerk in Server Actions
import { auth } from '@clerk/nextjs/server'

export async function createProject(data: ProjectInput) {
  const { userId } = await auth()
  if (!userId) throw new Error('Unauthorized')
  
  // userId is Clerk's user ID - sync to Profile table
  return await db.insertInto('Project').values({ ...data, userId })
}
```

## ðŸŽ¨ UI Components (shadcn/ui + Tailwind v4)

### Tailwind v4 Configuration

```css
/* app/globals.css */
@import "tailwindcss";

/* Define design tokens in @theme */
@theme {
  --color-primary: oklch(24% 0.15 256);
  --color-background: oklch(100% 0 0);
  --color-foreground: oklch(10% 0 0);
  
  --font-sans: 'Inter', system-ui, sans-serif;
  --radius: 0.5rem;
}

/* No more @tailwind directives or @layer needed */
```

### Component Setup

```bash
# Initialize shadcn/ui with Tailwind v4
npx shadcn@latest init

# Add components as needed
npx shadcn@latest add button form card toast
```

```typescript
// Feature component using shadcn/ui
import { Button } from '@/components/ui/button'
import { useToast } from '@/hooks/use-toast'

export function PostCard({ post }: { post: Post }) {
  const { toast } = useToast()
  
  async function handleLike() {
    const result = await likePost(post.id)
    
    toast({
      title: result.success ? "Liked!" : "Error",
      variant: result.success ? "default" : "destructive",
    })
  }
  
  return (
    <Card>
      <CardHeader>
        <CardTitle>{post.title}</CardTitle>
      </CardHeader>
      <CardContent>{post.content}</CardContent>
      <CardFooter>
        <Button onClick={handleLike}>Like</Button>
      </CardFooter>
    </Card>
  )
}
```

## ðŸ”¥ Real-time Subscriptions

```typescript
// hooks/use-realtime.ts
export function useRealtime<T extends keyof Database['public']['Tables']>(
  table: T,
  filter?: string
) {
  const [data, setData] = useState<Tables<T>[]>([])
  const supabase = createClient() // Client-side only

  useEffect(() => {
    const channel = supabase
      .channel(`realtime:${table}`)
      .on('postgres_changes', 
        { event: '*', schema: 'public', table, filter },
        (payload) => {
          if (payload.eventType === 'INSERT') {
            setData(prev => [payload.new as Tables<T>, ...prev])
          }
          // Handle UPDATE, DELETE
        }
      )
      .subscribe()

    return () => { channel.unsubscribe() }
  }, [table, filter])

  return data
}
```

## ðŸ§ª Testing Infrastructure (Vitest)

### When to Test

- **Business logic** in utilities and hooks
- **Server Actions** with mocked Supabase client
- **Component behavior** not visual appearance
- **Error states** and edge cases

### Setup

```bash
npm i -D vitest @testing-library/react @testing-library/user-event @vitejs/plugin-react jsdom
```

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    setupFiles: './test/setup.ts',
    globals: true,
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './'),
    },
  },
})

// test/setup.ts
import '@testing-library/jest-dom'
import { vi } from 'vitest'

// Mock Supabase client
vi.mock('@/lib/supabase/client', () => ({
  createClient: () => ({
    from: vi.fn(() => ({
      select: vi.fn(() => ({
        eq: vi.fn(() => Promise.resolve({ data: [], error: null })),
      })),
      insert: vi.fn(() => ({
        select: vi.fn(() => ({
          single: vi.fn(() => Promise.resolve({ data: {}, error: null })),
        })),
      })),
    })),
    auth: {
      getUser: vi.fn(() => Promise.resolve({ data: { user: null }, error: null })),
    },
  }),
}))
```

### Testing Patterns

```typescript
// components/features/posts/__tests__/post-card.test.tsx
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { PostCard } from '../post-card'

describe('PostCard', () => {
  const mockPost = {
    id: '1',
    title: 'Test Post',
    content: 'Test content',
    author: { name: 'John' },
  }

  it('renders post content', () => {
    render(<PostCard post={mockPost} />)
    expect(screen.getByText('Test Post')).toBeInTheDocument()
    expect(screen.getByText('Test content')).toBeInTheDocument()
  })

  it('calls onLike when like button clicked', async () => {
    const onLike = vi.fn()
    const user = userEvent.setup()
    
    render(<PostCard post={mockPost} onLike={onLike} />)
    await user.click(screen.getByRole('button', { name: /like/i }))
    
    expect(onLike).toHaveBeenCalledWith(mockPost.id)
  })
})

// server/actions/__tests__/posts.test.ts
import { createPost } from '../posts'
import { createClient } from '@/lib/supabase/server'

vi.mock('@/lib/supabase/server')

describe('createPost', () => {
  it('creates post and returns data', async () => {
    const mockSupabase = {
      from: vi.fn(() => ({
        insert: vi.fn(() => ({
          select: vi.fn(() => ({
            single: vi.fn(() => ({ 
              data: { id: '1', title: 'New Post' }, 
              error: null 
            })),
          })),
        })),
      })),
    }
    
    vi.mocked(createClient).mockResolvedValue(mockSupabase as any)
    
    const result = await createPost({ title: 'New Post', content: 'Content' })
    expect(result).toEqual({ id: '1', title: 'New Post' })
  })

  it('throws error on database failure', async () => {
    const mockSupabase = {
      from: vi.fn(() => ({
        insert: vi.fn(() => ({
          select: vi.fn(() => ({
            single: vi.fn(() => ({ 
              data: null, 
              error: new Error('Database error') 
            })),
          })),
        })),
      })),
    }
    
    vi.mocked(createClient).mockResolvedValue(mockSupabase as any)
    
    await expect(createPost({ title: 'Test', content: 'Test' }))
      .rejects.toThrow('Database error')
  })
})
```

## ðŸ“Š Database Patterns

### Type-Safe Queries

```typescript
// server/queries/posts.ts
import type { Database } from '@/types/supabase'

type Tables<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Row']

export async function getPosts() {
  const supabase = await createClient()
  
  const { data, error } = await supabase
    .from('posts')
    .select(`
      *,
      profiles!inner(username, avatar_url)
    `)
    .order('created_at', { ascending: false })

  if (error) throw error
  return data
}
```

### Row Level Security

```sql
-- Always enable RLS
ALTER TABLE posts ENABLE ROW LEVEL SECURITY;

-- Public read, authenticated write
CREATE POLICY "Public posts are viewable by everyone" ON posts
  FOR SELECT USING (published = true);

CREATE POLICY "Users can insert their own posts" ON posts
  FOR INSERT WITH CHECK (auth.uid() = author_id);
```

## ðŸš€ Performance Optimization

### Parallel Data Loading

```typescript
// Load data in parallel in Server Components
export default async function DashboardPage() {
  const [posts, profile, stats] = await Promise.all([
    getPosts(),
    getProfile(),
    getStats()
  ])
  
  return (
    <Dashboard 
      posts={posts} 
      profile={profile} 
      stats={stats} 
    />
  )
}
```

### Streaming with Suspense

```typescript
import { Suspense } from 'react'

export default function Page() {
  return (
    <>
      <Header />
      <Suspense fallback={<PostsSkeleton />}>
        <PostsList />
      </Suspense>
    </>
  )
}

async function PostsList() {
  const posts = await getPosts() // This can be slow
  return <>{posts.map(post => <PostCard key={post.id} post={post} />)}</>
}
```

## ðŸ”§ Development Workflow

### Essential Scripts

```json
{
  "scripts": {
    "dev": "next dev --turbo",
    "build": "next build",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "db:types": "supabase gen types --local > types/supabase.ts",
    "db:push": "supabase db push",
    "db:reset": "supabase db reset"
  }
}
```

### Environment Variables

```typescript
// lib/env.ts - Validated env vars
import { z } from 'zod'

const envSchema = z.object({
  NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string(),
  SUPABASE_SERVICE_ROLE_KEY: z.string().optional(),
})

export const env = envSchema.parse(process.env)
```

## âš¡ Key Commands

```bash
# Development
npm run dev --turbo          # Fast refresh with Turbopack
supabase start              # Local Supabase

# Testing
npm run test                # Run tests in watch mode
npm run test:ui            # Open Vitest UI
npm run test:coverage      # Generate coverage report

# Database
supabase db reset           # Reset + migrate
supabase gen types --local > types/supabase.ts

# UI Components
npx shadcn@latest add       # Add components

# Production
npm run build              # Type-safe build
supabase db push          # Deploy migrations
```

## ðŸš¨ Critical Rules

1. **Always regenerate types after schema changes**
2. **Use Server Components by default, Client Components when needed**
3. **Separate server and client Supabase instances**
4. **Use `after()` for non-blocking operations**
5. **Enable RLS on all tables**
6. **Compose UI with shadcn/ui components**
7. **Validate environment variables with Zod**
8. **Use Server Actions for mutations**
9. **Implement proper error boundaries**
10. **Stream data with Suspense for better UX**
11. **Test business logic, not implementation details**